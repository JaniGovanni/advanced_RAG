for unstructured you have to install sudo apt install libmagic1 poppler-utils libreoffice pandoc tesseract-ocr

on mac and windows it is better to run ollama outside a container, because
there is a performance decrease, because the docker container must also 
run a linux virtual machine to run the ollama server. On linux this is not necessary.
Also on mac, there seems to be no way for a container to access the GPU

jina api jina_31bf3288e9494ac69db2cd6a25eaba10vfnAa-YJt4PmS6qUOJfQ7ih-pH64

* Process, structure and store all kind of document types and also providing options to filter out unwanted document sections for efficient retrieval.
* Combine more than one documents to build a knowledge base.
* Implement various RAG techniques (multi query, HyDE, BM25, Contextual Retrieval,...) to enhance query understanding and document retrieval.
* Ability to run the software completely locally using Ollma (llama3.2:3b, llama3.2:1b, nomic-embed-text) and ChromaDB or via API support from Groq.
* Provide a flexible and configurable chat interface for interacting with the system.
* Include evaluation and testing capabilities to assess the RAG-system's performance.
* Easy deployment via Streamlit UI and containerisation with docker-compose


bugs:

- when adding something to the unwanted section list and hit doc processing before pressing enter,
  the unwanted title is added 2 times to the list (second_page.py)
- bm25 retrieval helper functions must be tested



The separation of frontend and backend can indeed improve scalability and maintainability, but it depends on how it's implemented and the specific needs of your project. Here are some considerations:
Scalability
Frontend and Backend Separation: By separating the frontend (Streamlit) and backend (Flask API), you can scale each component independently. For example, if the backend API becomes a bottleneck, you can scale it horizontally by adding more instances without affecting the frontend.
Load Distribution: This architecture allows you to distribute the load more effectively. You can use load balancers to manage traffic to the backend services, which can be particularly useful if you have a high number of concurrent users.
Maintainability
Code Organization: Separating concerns can lead to cleaner, more organized code. The frontend can focus on user interaction and presentation, while the backend handles data processing and business logic.
Independent Development: Teams can work on the frontend and backend independently, which can speed up development and make it easier to manage changes.
Technology Flexibility: You can update or replace one part of the system without affecting the other. For instance, you could switch from Flask to another backend framework if needed, without changing the frontend.
Potential Drawbacks
Complexity: This architecture can introduce additional complexity, such as managing API endpoints, handling cross-origin requests, and ensuring consistent data models between the frontend and backend.
Overhead: There might be some overhead in terms of network latency and data serialization/deserialization between the frontend and backend.
In summary, while the separation can improve scalability and maintainability, it also introduces complexity that needs to be managed. The decision should be based on the specific requirements and constraints of your project. If your application is expected to grow in terms of user base or functionality, this separation can be beneficial. However, for smaller projects, the added complexity might not be justified.

